메모리가 부족하다고 생각되는 시점에 Garbage Collector가 실행되서 Garbage 메모리를 찾아 청소해서 확보한다.(당장 써야할 컵이 없는데 설거지대에 다쓴 컵이 있으면 설거지 하는 느낌)

CPU가 한가할 때에도 찾아서 확보한다.

Constant Pool(상수 풀)은 Permanent area(고정영역) 에 있다 -> Java 프로세스 (JVM) 종료때까지 유지


Java 세계에서는 객체 배열은 만들 수 없다 ( C++은 가능)  -> 대신 주소(reference)를 담는 변수의 배열을 만든다 -> Heap에 만들어짐

Java의 목적은 OS 독립적이게 하는 것

객체지향의 목적은 실행속도가 다소 느려져도 소스코드의 유지/보수가 쉬워지게 하는 것
-> 다수의 메소드가 있다고 할 때 관리가 어렵다 -> Classfication(분류)를 해야할 필요가 있다 -> 'Class'로 묶어서 분류 -> Refactoring 의 한 종류
-> 기능이 느려졌을때 특정 부분의 성능을 개선하는 것이 옵티마이징이라고 한다


변수에 static이 붙는 순간 메모리를 만든다

데이터를 개별적으로 다뤄야 하는 경우는 인스턴스 변수를 만들고 공유를 해야 할 때에는 static 변수를 만든다.

Java에서는 모든 객체는 stack에 만들어진다

Java에서는 If문에서 참 혹은 거짓밖에 없다 -> if가 참일때 or 아닐때 else -> if~else는 원래 한문장이다 
-> else if는 한문장일 경우{} 를 생략할수 있는 것 때문에 생략해서 else if가 붙어있다 보니 그렇게 보이는 것 원래는 else if따로임

사용객체와 피사용객체 사이의 호출 규칙을 정리하는 것이 '인터페이스'이다 -> 다음번 누가 객체를 만들더라도 똑같은 규칙을 따르게 하는 것

서브클래스들의 공통점을 모아서 일반화시키고(Super Class)  그것을 상속받아 사용하게 만드는 것이 추상클래스이다.


Low Coupling -> 낮은 결합도

High Cohesion -> 높은 응집도

어떠한 것을 할 때 '이것'이 없으면 못한다 -> 그렇다면 '이것'은 의존객체이다

생성자는 객체를 만들 때 바로 쓸 수 있게 하기 위해 필요한 최소 요소를 꼽아주는 역할

사용자 정의 데이터 타입 : Domain -> 객체와 객체 사이에서 데이터를 주고받는 데이터 타입(회사별로 다름. 어떤곳은 DTO, 어떤곳은 VO)

아주 특별한 경우가 아니면 패키지 이름은 무조건 소문자로만!

private은 같은 클래스에서만 가능

디폴트와 protected는 둘다 같은 패키지에서만 접근가능 -> protected는 자식 클래스(sub class)이어도 접근 가능

public static final int a; => 여기서 public, static , final 은 modifier라고 한다. 원래 성질을 변화시키는 요소.

개별적으로 관리할 변수가 있다면 인스턴스 변수로 만든다.

기능확장을 쉽게 하라고 만든 것이 상속이다.

클래스 로딩은 사용하는 시점에 딱 한번만 된다. ( 클래스 로딩 : ~~.class파일을 JVM의 메모리에 로딩하는 것)

객체지향설계서에서는 메서드를 operator 라고한다

모든 인스턴스 메서드는 this라는 내장된 변수를 가지고있다. 기본적으로는 생략, setter의 경우는 생략하면 로컬변수와 헷갈릴 수 있기 때문에 표기를 해준다.

인스턴스 없이 작업할때 필요한 메서드는 클래스 메서드로 만든다

static 메서드는 this가 없음 -> 인스턴스를 사용하지 않는다 -> 들어온 값을 통해 사용

this 의 주소는 호출할때마다 바뀐다.

인스턴스 메서드는 실제로 인스턴스 주소가 있는 상태(new로 Heap에 메모리 할당)에서 사용한다.

Heap 안에 인스턴스 안에는 메서드가 없다. 메서드는 Method Area에 있다. this는 Method Area에 있고 호출하는 주소에 따라 달리 값을 넣어 작동한다. 실제로는 1개이다.

*인스턴스를 사용 - 인스턴스 메서드 ,  사용 X  - static 메서드 로 설계한다.

이클립스에서 변수 클릭 후 refactor-rename 하면 해당하는 변수 이름이 한꺼번에 바뀐다~!

자바에서의 프로퍼티는 setter/getter 이다. 프로퍼티명은 앞에 set,get을 뺀 글자의 소문자명-> MyBatis에서 사용할때에도 getName() -> #{name}

public을 쓰지않고 private로 막아놓고 getter/setter를 계속 만드는 꼬박꼬박 이유는 '일관성', '향후 확장성' 이유가 크다. 인터페이스 또한 그렇다.

setter/getter 를 operator로 봐도 된다 -> 인스턴스를 다루는 메서드

<실습순서>

대상 프로젝트 클론 -> 클론한 프로젝트에서 실습대상 항목 복사해서 newdeal 폴더에 붙여넣고 이름 바꾸기 -> visual stuido code에서 settings.gradle에 있는 프로젝트명 변경
-> cmd창에서 해당 프로젝트로 이동 후 gradle eclipse 실행 -> 이클립스에서 import -> git master에서 작업했을 경우 add,commit후 branch 삭제 이후 다시 branch 생성